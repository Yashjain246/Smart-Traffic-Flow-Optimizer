// This Module object is the hook that Emscripten-generated code looks for.
// We are redirecting its standard output and error streams to our own function
// which will then write the simulation output to the webpage.
var Module = {
    // When the C++ code calls `std::cout`, this function will be called.
    print: (function() {
        const outputLog = document.getElementById('output-log');
        return function(text) {
            if (arguments.length > 1) {
                text = Array.prototype.slice.call(arguments).join(' ');
            }
            console.log(text);
            if (outputLog) {
                outputLog.textContent += text + "\n";
                // Auto-scroll to the bottom of the log
                outputLog.scrollTop = outputLog.scrollHeight;
            }
        };
    })(),
    // When the C++ code calls `std::cerr`, this function will be called.
    printErr: function(text) {
        if (arguments.length > 1) {
            text = Array.prototype.slice.call(arguments).join(' ');
        }
        console.error(text);
        const outputLog = document.getElementById('output-log');
        if (outputLog) {
            outputLog.textContent += "[ERROR] " + text + "\n";
            outputLog.scrollTop = outputLog.scrollHeight;
        }
    },
};

// This is an event listener that Emscripten will call when the WebAssembly module is ready to use.
window.addEventListener('load', () => {
    // The SmartTrafficModule function is created by the 'module.js' file generated by Emscripten.
    // We pass our Module object to it to hook into its lifecycle.
    SmartTrafficModule(Module);
});

// --- Simulation Control ---

const form = document.getElementById('simulation-form');
const runButton = document.getElementById('runButton');

// Listen for the form submission event.
form.addEventListener('submit', (event) => {
    event.preventDefault(); // Prevent the default form submission behavior
    runSimulation();
});

function runSimulation() {
    const outputLog = document.getElementById('output-log');
    outputLog.textContent = 'Initializing simulation...\n\n';
    
    // Disable the button to prevent multiple runs
    runButton.disabled = true;
    runButton.textContent = 'Running...';

    // Get the simulation parameters from the form inputs.
    const numVehicles = document.getElementById('numVehicles').value;
    const simDuration = document.getElementById('simDuration').value;
    const startNode = document.getElementById('startNode').value;
    const endNode = document.getElementById('endNode').value;

    // These arguments will be passed as `argc` and `argv` to the main() function in your C++ code.
    const args = [
        numVehicles,
        simDuration,
        startNode,
        endNode
    ];

    // We wrap this in a timeout to allow the UI to update with "Initializing..."
    // before the potentially blocking WebAssembly code runs.
    setTimeout(() => {
        try {
            // This is the main call that executes your C++ code.
            Module.callMain(args);
        } catch (e) {
            console.error(e);
            Module.printErr(e.toString());
        } finally {
            // Re-enable the button after the simulation is finished or an error occurs.
            runButton.disabled = false;
            runButton.textContent = 'Run Simulation';
            Module.print("\n...Simulation finished.");
        }
    }, 50);
}

